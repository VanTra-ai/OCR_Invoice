<!-- imglab/tags/workarea.tag.html -->
<workarea>
  <style>
    #work-canvas {
      position: absolute;
      z-index: 1;
      top: 0;
      left: 0;
    }
    #canvas-container {
      height: calc(100vh - 190px);
      display: block;
      overflow: auto;
      position: relative;
      background-color: #333;
    }
    #img {
      display: block;
      user-select: none;
    }
    .placeholder-msg {
      color: #aaa;
      text-align: center;
      padding-top: 50px;
    }
    .hidden {
      display: none !important;
    }
    .visible {
      display: block !important;
    }
  </style>

  <div id="canvas-container">
    <div class="{ imgSelected ? 'hidden' : 'visible' } placeholder-msg">
      <h4>No image selected</h4>
      <p>Please upload and select an image from the bottom slider.</p>
    </div>
    <img id="img" class="{ imgSelected ? 'visible' : 'hidden' }" src={
    imgSelected ? imgSelected.src : "" } />
    <div id="work-canvas" class="{ imgSelected ? 'visible' : 'hidden' }"></div>
    <trackinglines></trackinglines>
  </div>

  <script>
    var self = this;
    var myCanvas = null;
    self.imgSelected = window.imgSelected || opts.img;

    function getColorByLabel(label) {
      if (typeof labelColors !== "undefined" && labelColors[label]) {
        return labelColors[label];
      }
      return "#00ff00";
    }

    this.on("update", function (updatedOpts) {
      self.imgSelected = window.imgSelected || (updatedOpts && updatedOpts.img);
    });
    this.on("updated", function () {
      setTimeout(initWorkArea, 50);
    });

    this.on("mount", function () {
      setTimeout(initWorkArea, 50);

      if (typeof eventBus !== "undefined") {
        eventBus.on("labelChanged", function (shapeId, label, color) {
          console.log("üé® ƒê·ªïi m√†u:", shapeId, color);

          // 1. C·∫≠p nh·∫≠t Giao Di·ªán (D√πng style tr·ª±c ti·∫øp ƒë·ªÉ ƒë√® CSS)
          if (myCanvas) {
            var el = SVG.get(shapeId);
            if (el) {
              // C·∫≠p nh·∫≠t thu·ªôc t√≠nh SVG
              el.stroke({ color: color });
              el.fill({ color: color, opacity: 0.2 });

              // --- FIX: C·∫¨P NH·∫¨T TR·ª∞C TI·∫æP CSS STYLE ---
              if (el.node) {
                el.node.style.stroke = color;
                el.node.style.fill = color;
                el.node.style.fillOpacity = 0.2;
              }
            }
          }

          // 2. C·∫≠p nh·∫≠t D·ªØ Li·ªáu
          if (
            labellingData &&
            self.imgSelected &&
            labellingData[self.imgSelected.name]
          ) {
            var shapes = labellingData[self.imgSelected.name].shapes;
            var shapeData = shapes.find((s) => s.id === shapeId);
            if (shapeData) {
              if (!shapeData.attributes) shapeData.attributes = [];
              if (shapeData.attributes.length > 0) {
                shapeData.attributes[0].label = label;
              } else {
                shapeData.attributes.push({ label: label, value: "" });
              }
            }
          }
        });
      }
    });

    this.on("unmount", function () {
      $(document).off("keyup");
      $(document).off("click");
      if (typeof eventBus !== "undefined") eventBus.off("labelChanged");
    });

    var initRetryCount = 0;
    function initWorkArea() {
      if (!self.imgSelected) return;
      var canvasEl = self.root.querySelector("#work-canvas");
      var imgEl = self.root.querySelector("#img");
      if ((!canvasEl || !imgEl) && initRetryCount < 20) {
        initRetryCount++;
        setTimeout(initWorkArea, 100);
        return;
      }
      initRetryCount = 0;

      var width = self.imgSelected.size.scaledWidth;
      var height = self.imgSelected.size.scaledHeight;
      imgEl.width = width;
      imgEl.height = height;
      imgEl.style.opacity = appConfig.imageOpacity || 1;

      if (myCanvas === null) {
        if (canvasEl.children.length === 0) {
          myCanvas = new SVG(canvasEl).size(width, height);
          attachMouseEvents();
          if (typeof eventBus !== "undefined")
            eventBus.trigger("unmountLabelPanel");
        } else {
          myCanvas = SVG.adopt(canvasEl.children[0]);
          myCanvas.off("mousedown");
          myCanvas.off("mouseup");
          attachMouseEvents();
        }
      }
      if (myCanvas) {
        myCanvas.size(width, height);
        myCanvas.clear();
        drawOnCanvas();
      }
    }

    function attachMouseEvents() {
      if (!myCanvas) return;
      myCanvas.on("mousedown", function (event) {
        deselectAll();
        if (selectedTool && !alreadyDrawing && selectedTool.drawable) {
          var currentTool = selectedTool.create(event, myCanvas);

          // M·∫∑c ƒë·ªãnh v·∫Ω m√†u xanh
          var defColor = "#00ff00";
          currentTool.stroke({ color: defColor });
          if (currentTool.node) currentTool.node.style.stroke = defColor;

          moveOnlyOnMoveTool(currentTool);
          attachShapeListener(currentTool);
          currentTool.draw(event);
          selectedElement = currentTool;
        }
      });
      myCanvas.on("mouseup", function (event) {
        if (selectedTool && selectedElement) selectedElement.draw(event);
      });
    }

    $(document).on("click", function (event) {
      if (
        !$(event.target).closest("#work-canvas").length &&
        !$(event.target).closest(".tool-button").length &&
        !$(event.target).closest("label-panel").length
      ) {
        deselectAll();
      }
    });

    $(document).keyup(function (e) {
      if (selectedElements.length > 0) {
        if (e.keyCode == 46) {
          // Delete
          selectedElements.forEach((el) => {
            detachShape(el.node.id);
            el.parent().remove();
            if (typeof eventBus !== "undefined")
              eventBus.trigger("removeLabelPanelTag");
          });
          selectedElements = [];
        } else if (e.key === "c" && e.ctrlKey) {
          // Copy
          copiedElements = [];
          selectedElements.forEach((shape) => {
            if (shape.hasClass("shape")) {
              copiedElements.push({
                type: shape.type,
                rbox: shape.rbox(myCanvas),
                points: getPoints(shape),
              });
            }
          });
        }
      }
      if (e.key === "v" && e.ctrlKey) {
        // Paste
        var currentImgData = labellingData[self.imgSelected.name];
        if (
          typeof copiedElements !== "undefined" &&
          copiedElements.length > 0
        ) {
          copiedElements.forEach((shape) => {
            var shapeId = shape.type + currentImgData.shapeIndex++;
            attachShapeToImg(shapeId, shape.type, shape.rbox, shape.points);
          });
          self.update();
        }
      } else if (e.key === "a" && e.ctrlKey) {
        selectAll();
      }
    });

    function attachShapeListener(shape) {
      shape.on("drawstart", function () {
        alreadyDrawing = true;
      });
      shape.on("drawstop", function () {
        alreadyDrawing = false;
        if (!selectedTool.validate(shape)) {
          shape.parent().remove();
          shape.remove();
        } else {
          attachShapeData(shape);
          attachEvents(shape);
          deselectAll();
          shape.selectize({ rotationPoint: false });
          selectedElements.push(shape);
          if (typeof eventBus !== "undefined")
            riot.mount("label-panel", { id: shape.node.id });
        }
      });
      shape.on("resizedone", function () {
        updateShapeDetailInStore(
          shape.node.id,
          shape.rbox(myCanvas),
          getPoints(shape)
        );
      });
    }

    function attachEvents(currentTool) {
      moveOnlyOnMoveTool(currentTool);
      onMouse(currentTool.parent(), function (e) {
        if (currentTool.node.id === e.target.id) {
          updateShapeDetailInStore(
            currentTool.node.id,
            currentTool.rbox(myCanvas),
            getPoints(currentTool)
          );
        }
      });
      currentTool.parent().on("click", function (e) {
        if (!e.ctrlKey) {
          deselectAll();
          if (typeof eventBus !== "undefined")
            riot.mount("label-panel", { id: currentTool.node.id });
        }
        currentTool.selectize({ rotationPoint: false });
        selectedElements.push(currentTool);
        e.stopPropagation();
      });
    }

    function moveOnlyOnMoveTool(el) {
      el.on("mousedown", function (e) {
        if (!selectedTool || selectedTool.type !== "move") {
          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    function onMouse(shape, dragCB) {
      var mousestate = 0;
      shape.on("mousedown", function (e) {
        mousestate = 1;
        shape.on("mousemove", function (e) {
          mousestate = 2;
        });
        shape.on("mouseup", function (e) {
          if (mousestate === 2) {
            dragCB && dragCB(e);
          }
          mousestate = 0;
        });
        e.stopPropagation();
      });
    }

    function deselectAll() {
      if (typeof selectedElements !== "undefined") {
        selectedElements.forEach((el) => {
          el.selectize(false);
        });
        selectedElements = [];
      }
    }

    function selectAll() {
      if (labellingData[self.imgSelected.name]) {
        labellingData[self.imgSelected.name].shapes.forEach((shape) => {
          let el = SVG.get(shape.id);
          if (el) {
            el.selectize({ rotationPoint: false });
            selectedElements.push(el);
          }
        });
      }
    }

    function attachShapeData(shape) {
      var points = getPoints(shape);
      attachShapeToImg(shape.node.id, shape.type, shape.rbox(myCanvas), points);
    }

    function getPoints(shape) {
      if (shape.type === "rect") {
        var box = shape.rbox(myCanvas);
        return [box.x, box.y, box.w, box.h];
      }
      return [];
    }

    function drawOnCanvas() {
      if (!labellingData || !labellingData[self.imgSelected.name]) return;
      for (var shapeIndex in labellingData[self.imgSelected.name].shapes) {
        var shape = labellingData[self.imgSelected.name].shapes[shapeIndex];
        drawShape(shape);
      }
    }

    function drawShape(shape) {
      if (!shape || !myCanvas) return;
      var scale = self.imgSelected.size.imageScale;
      var currentShape;

      if (shape.type === "rect") {
        try {
          var rect = myCanvas
            .nested()
            .rect(shape.points[2] * scale, shape.points[3] * scale)
            .move(shape.points[0] * scale, shape.points[1] * scale)
            .addClass("labelbox shape")
            .id(shape.id)
            .resize();

          // --- FIX: C·∫¨P NH·∫¨T STYLE TR·ª∞C TI·∫æP ---
          var shapeColor = "#00ff00";
          if (shape.attributes && shape.attributes.length > 0) {
            var label = shape.attributes[0].label;
            shapeColor = getColorByLabel(label);
          }
          rect.stroke({ color: shapeColor, width: 2 });
          rect.fill({ color: shapeColor, opacity: 0.2 });

          // √âp bu·ªôc c·∫≠p nh·∫≠t style
          if (rect.node) {
            rect.node.style.stroke = shapeColor;
            rect.node.style.fill = shapeColor;
            rect.node.style.fillOpacity = 0.2;
          }

          rect.parent().draggable();
          currentShape = rect;
        } catch (e) {
          console.error("L·ªói v·∫Ω h√¨nh:", e);
        }
      }

      if (currentShape) {
        moveOnlyOnMoveTool(currentShape);
        attachEvents(currentShape);
        attachShapeListener(currentShape);
      }
    }
  </script>
</workarea>
